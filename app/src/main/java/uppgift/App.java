/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package uppgift;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;

import uppgift.MethodTimer.Result;

public class App {

    public static void main(String[] args) {
         DequeTest();
         RandomQueueTest();
         BinarySearchTreeTest();
         AVLTreeTest();
         QPHashTableTest();

 

         warmUp();
         try {
            VehicleTest();
        } catch (Exception e) {
            System.out.println("VehicleTest failed");
            e.printStackTrace();
        }


        TreeExperiment experiment = new TreeExperiment();

        try {
            experiment.runExperiment();
        } catch (Exception e) {
            e.printStackTrace();
        }

        
    }

    private static void warmUp() {
        // Dummy operations
        for (int i = 0; i < 10000; i++) {
            Math.sqrt(i);
        }

        // Explicit Garbage Collection (if applicable)
        System.gc();

        // CPU Stabilization
        long startTime = System.currentTimeMillis();
        while (System.currentTimeMillis() - startTime < 5000) {
            Math.random();
        }

    

        // Repeat Runs for stabilization
        for (int i = 0; i < 5; i++) {
            dummyRun();
        }
    }

    private static void dummyRun() {
        // Use a very small dataset for the warm-up
        Vehicle[] vehicles = new Vehicle[20];
        for (int i = 0; i < vehicles.length; i++) {
            vehicles[i] = new Vehicle("ABC" + i + i + i); // Simplified vehicle creation
        }

        // Simplified insertion without extra calculations
        QuadraticProbingHashTable<Vehicle> myQPHT = new QuadraticProbingHashTable<>();
        for (int i = 0; i < vehicles.length; i++) {
            myQPHT.insert(vehicles[i]);
        }
    }

    private static void TestHashCodePerformance() {
        String[] testInputs = { "ABC123", "DEF4567", "GHI89012", "JKL345678", "MNO7890123" };
        for (String input : testInputs) {
            Vehicle vehicle = new Vehicle(input);

            long startTime = System.nanoTime();
            vehicle.hashCode();
            long endTime = System.nanoTime();

            System.out
                    .println("Time taken to compute hash for " + input + ": " + (endTime - startTime) + " nanoseconds");
        }
    }
    private static void VehicleTest() throws Exception {
        VehicleCreator vc = new VehicleCreator(38400);
        Vehicle[] vehicles = vc.getVehicles();
        MethodTimer timer = new MethodTimer();

        int[] insertAmounts = { 200, 400, 800, 1200, 2400, 4800, 9600, 19200, 38400 };

        for (int amount : insertAmounts) {
            System.out.println("---------------------------------------------------------");
            System.out.println("Inserting " + amount + " vehicles");

            // Define the insertion task as a Callable
            Callable<Void> insertionTask = () -> {
                QuadraticProbingHashTable<Vehicle> myQPHT = new QuadraticProbingHashTable<>();
                for (int i = 0; i < amount; i++) {
                    myQPHT.insert(vehicles[i]);
                }
                return null;
            };

            // Measure the execution time of the insertion task
            MethodTimer.Result result = timer.measure(insertionTask, 50, 50);

            System.out.println("Time taken for insertion of " + amount + " vehicles: " + (result.mean * 1.0e-6) + " ms");
            System.out.println("Median Execution Time: " + (result.median * 1.0e-6) + " ms");

            // Retrieve the hash table for statistics after insertion
            QuadraticProbingHashTable<Vehicle> myQPHT = new QuadraticProbingHashTable<>();
            for (int i = 0; i < amount; i++) {
                myQPHT.insert(vehicles[i]);
            }

            System.out.println("Amount of collisions: " + myQPHT.getCollisionCount());
            System.out.println("Collision Rate: " + myQPHT.getCollisionRate());
            System.out.println("Collisions per Bucket: " + myQPHT.getCollisionsPerBucket());
            System.out.println("Bucket Utilization: " + myQPHT.getBucketUtilization());
            System.out.println("Load Factor: " + myQPHT.getLoadFactor());
            System.out.println("Standard Deviation of Bucket Distribution: " + myQPHT.analyzeBucketDistribution());
            System.out.println("Bucket distribution summary: " + myQPHT.getDistributionSummary());
            System.out.println("Number of Rehashes: " + myQPHT.getRehashCount());
            System.out.println(" ");
        }
    }

    private static void QPHashTableTest() {

        QuadraticProbingHashTable<Integer> myQPHT = new QuadraticProbingHashTable<>();

        myQPHT.insert(13);
        myQPHT.printTable();
        myQPHT.insert(25);
        myQPHT.printTable();
        myQPHT.insert(67);
        myQPHT.insert(9);
        myQPHT.insert(99);
        myQPHT.insert(2);
        myQPHT.insert(43);
        myQPHT.insert(36);
        myQPHT.insert(130);
        myQPHT.insert(74);
        myQPHT.printTable();
        myQPHT.insert(11);
        myQPHT.printTable();

        System.out.println(myQPHT.contains(130));
        myQPHT.remove(130);
        myQPHT.printTable();
        System.out.println(myQPHT.contains(130));

    }
   

    private static void AVLTreeTest() {
        AVLTree<Integer> myAVL = new AVLTree<>();

        int[] elementsToAdd = { 3, 2, 1, 4, 5, 6, 7, 16, 15, 14, 13, 12, 11, 10, 8, 9 };
        for (int element : elementsToAdd) {
            System.out.println("Adding: " + element);
            myAVL.add(element);
            myAVL.printTree();
            System.out.println("Is balanced: " + myAVL.isBalanced());
        }

        int[] elementsToRemove = { 3, 4, 5 };
        for (int element : elementsToRemove) {
            System.out.println("Removing: " + element);
            myAVL.remove(element);
            myAVL.printTree();
            System.out.println("Is balanced: " + myAVL.isBalanced());
        }
    }



    private static void BinarySearchTreeTest() {
        BinarySearchTree<Integer> myBST = new BinarySearchTree<>();
        System.out.println(myBST.size()); // bör vara noll

        myBST.add(4);
        myBST.add(2);
        myBST.add(6);
        myBST.add(5);
        myBST.add(9);
        myBST.add(7);
        myBST.add(11);

        System.out.println(" ");

        myBST.inorderIterator();
        System.out.println(" ");
        myBST.preorderIterator();
        System.out.println(" ");
        myBST.postorderIterator();

        System.out.println("  ");

        System.out.println(myBST.size()); // bör vara 7
        myBST.remove(6);
        System.out.println(myBST.size()); // bör vara 6

        System.out.println(myBST.contains(5)); // bör vara true
        System.out.println(myBST.contains(6)); // bör vara false

        System.out.println(" ");
        myBST.removeKLargest(3);
        myBST.inorderIterator(); // bör vara utan 7
        System.out.println();
    }

    private static void RandomQueueTest() {
        RandomQueue<String> myRandomQueue = new RandomQueue<>();

        System.out.println(myRandomQueue.isEmpty()); // bör vara true
        System.out.println(myRandomQueue.size()); // bör vara noll

        myRandomQueue.enqueue("apple");
        myRandomQueue.enqueue("banana");
        myRandomQueue.enqueue("pear");
        myRandomQueue.enqueue("orange");

        System.out.println(myRandomQueue.isEmpty()); // bör vara false
        System.out.println(myRandomQueue.size()); // bör vara 4

        System.out.println("Random iteration:");
        for (String i : myRandomQueue) {
            System.out.println(i);
        }

        System.out.println("Another random iteration:");
        for (String i : myRandomQueue) {
            System.out.println(i);
        }

        System.out.println("Removed: " + myRandomQueue.dequeue());
        System.out.println(myRandomQueue.size()); // bör vara 3

    }

    private static void DequeTest() {
        Deque<String> myDeque = new Deque<>();
        System.out.println(myDeque.isEmpty()); // bör vara true
        System.out.println(myDeque.size()); // bör vara noll

        myDeque.addFirst("apple");
        myDeque.addFirst("banana");
        myDeque.addLast("pear");
        myDeque.addLast("orange");

        for (String i : myDeque) {
            System.out.println(i);
        }

        System.out.println("Removed from head: " + myDeque.removeFirst());
        System.out.println("Removed from tail: " + myDeque.removeLast());

        for (String i : myDeque) {
            System.out.println(i);
        }

        System.out.println(myDeque.isEmpty()); // bör vara false
        System.out.println(myDeque.size()); // bör vara 2
    }
}
